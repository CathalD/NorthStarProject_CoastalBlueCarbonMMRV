# ============================================================================
# MODULE 07B: COMPREHENSIVE STANDARDS COMPLIANCE REPORT
# ============================================================================
# PURPOSE: Generate comprehensive report with all figures, maps, and outputs
#          from Modules 01-07, with detailed standards compliance checking and
#          actionable recommendations for achieving project goals
#
# STANDARDS COVERED:
#   - VM0033 (Verra) - Tidal Wetland & Seagrass Restoration
#   - ORRAA - High Quality Blue Carbon Principles
#   - IPCC Wetlands Supplement
#   - Canadian Blue Carbon Network Standards
#
# INPUTS:
#   - All outputs from Modules 01-07 (carbon stocks, predictions, diagnostics)
#   - All figures and maps generated by previous modules
#   - Cross-validation results, uncertainty estimates
#   - Field data quality metrics
#
# OUTPUTS:
#   - outputs/reports/comprehensive_standards_report.html
#   - outputs/reports/standards_compliance_summary.csv
#   - outputs/reports/recommendations_action_plan.csv
#   - outputs/reports/figures/all_consolidated_figures/
# ============================================================================

# Clear workspace
rm(list = ls())

# Load required libraries
suppressPackageStartupMessages({
  library(terra)
  library(sf)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(readr)
  library(gridExtra)
})

# Load configuration
source("blue_carbon_config.R")

# ============================================================================
# SETUP LOGGING
# ============================================================================

log_message <- function(msg, level = "INFO") {
  timestamp <- format(Sys.time(), "[%Y-%m-%d %H:%M:%S]")
  cat(sprintf("%s %s: %s\n", timestamp, level, msg))
}

log_message("=== MODULE 07B: COMPREHENSIVE STANDARDS COMPLIANCE REPORT ===")
log_message(sprintf("Project: %s", PROJECT_NAME))

# Create output directories
dir.create("outputs/reports", recursive = TRUE, showWarnings = FALSE)
dir.create("outputs/reports/figures", recursive = TRUE, showWarnings = FALSE)

# ============================================================================
# STANDARDS COMPLIANCE CRITERIA
# ============================================================================

log_message("\nDefining standards compliance criteria...")

# VM0033 (Verra) Requirements
vm0033_criteria <- list(
  name = "VM0033 - Tidal Wetland & Seagrass Restoration",
  requirements = list(
    list(
      criterion = "Minimum samples per stratum",
      threshold = VM0033_MIN_CORES,
      check_function = function(data) {
        if (is.null(data$cores)) return(list(pass = FALSE, value = NA, message = "No core data"))

        samples_per_stratum <- data$cores %>%
          group_by(stratum) %>%
          summarise(n_cores = n_distinct(core_id), .groups = "drop")

        min_samples <- min(samples_per_stratum$n_cores, na.rm = TRUE)
        pass <- all(samples_per_stratum$n_cores >= VM0033_MIN_CORES)

        message <- if (pass) {
          sprintf("All strata have ‚â•%d samples (min: %d)", VM0033_MIN_CORES, min_samples)
        } else {
          failing_strata <- samples_per_stratum %>%
            filter(n_cores < VM0033_MIN_CORES)
          sprintf("FAIL: %d strata below minimum (%s)",
                  nrow(failing_strata),
                  paste(failing_strata$stratum, collapse = ", "))
        }

        list(pass = pass, value = min_samples, message = message,
             details = samples_per_stratum)
      }
    ),
    list(
      criterion = "Target precision (relative error at 95% CI)",
      threshold = paste0("‚â§", VM0033_TARGET_PRECISION, "%"),
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        # Calculate relative error from carbon stocks
        stocks <- data$carbon_stocks %>%
          filter(stratum != "ALL") %>%
          mutate(
            relative_error = ifelse(mean_stock_0_100_Mg_ha > 0,
                                   100 * (mean_stock_0_100_Mg_ha - conservative_stock_0_100_Mg_ha) / mean_stock_0_100_Mg_ha,
                                   NA)
          )

        max_error <- max(stocks$relative_error, na.rm = TRUE)
        pass <- max_error <= VM0033_TARGET_PRECISION

        message <- if (pass) {
          sprintf("All strata within target (max: %.1f%%)", max_error)
        } else {
          failing_strata <- stocks %>% filter(relative_error > VM0033_TARGET_PRECISION)
          sprintf("FAIL: %d strata exceed %.0f%% (max: %.1f%%)",
                  nrow(failing_strata), VM0033_TARGET_PRECISION, max_error)
        }

        list(pass = pass, value = max_error, message = message, details = stocks)
      }
    ),
    list(
      criterion = "Standard depths measured",
      threshold = "0-15, 15-30, 30-50, 50-100 cm",
      check_function = function(data) {
        if (is.null(data$cores)) return(list(pass = FALSE, value = NA, message = "No core data"))

        # Check if all VM0033 depths are represented
        required_depths <- VM0033_DEPTH_MIDPOINTS
        available_depths <- unique(data$cores$depth_midpoint_cm)

        has_all_depths <- all(required_depths %in% available_depths)

        message <- if (has_all_depths) {
          "All VM0033 standard depths present"
        } else {
          missing <- setdiff(required_depths, available_depths)
          sprintf("FAIL: Missing depths: %s cm", paste(missing, collapse = ", "))
        }

        list(pass = has_all_depths,
             value = length(available_depths),
             message = message,
             details = list(required = required_depths, available = available_depths))
      }
    ),
    list(
      criterion = "Conservative estimates used",
      threshold = "95% CI lower bound",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        # Check if conservative estimates are available and < mean
        has_conservative <- "conservative_stock_0_100_Mg_ha" %in% names(data$carbon_stocks)

        if (has_conservative) {
          stocks <- data$carbon_stocks %>%
            filter(stratum != "ALL", !is.na(conservative_stock_0_100_Mg_ha))

          all_conservative_lower <- all(stocks$conservative_stock_0_100_Mg_ha < stocks$mean_stock_0_100_Mg_ha)

          message <- if (all_conservative_lower) {
            sprintf("Conservative estimates properly calculated (%d strata)", nrow(stocks))
          } else {
            "FAIL: Some conservative estimates ‚â• mean"
          }

          list(pass = all_conservative_lower, value = "Yes", message = message)
        } else {
          list(pass = FALSE, value = "No", message = "FAIL: Conservative estimates not calculated")
        }
      }
    ),
    list(
      criterion = "Verification frequency",
      threshold = paste0("Every ", VM0033_MONITORING_FREQUENCY, " years"),
      check_function = function(data) {
        # This is a temporal requirement - can only check if temporal data exists
        message <- sprintf("Requirement: Monitoring every %d years (temporal module needed)",
                          VM0033_MONITORING_FREQUENCY)
        list(pass = NA, value = "N/A", message = message)
      }
    ),
    list(
      criterion = "Cross-validation performed",
      threshold = "Required for spatial predictions",
      check_function = function(data) {
        cv_exists <- !is.null(data$cv_results) && nrow(data$cv_results) > 0

        message <- if (cv_exists) {
          mean_r2 <- mean(data$cv_results$cv_r2, na.rm = TRUE)
          sprintf("Cross-validation performed (mean R¬≤: %.3f)", mean_r2)
        } else {
          "FAIL: No cross-validation results found"
        }

        list(pass = cv_exists, value = cv_exists, message = message)
      }
    )
  )
)

# ORRAA (Ocean Risk & Resilience Action Alliance) High Quality Blue Carbon Principles
orraa_criteria <- list(
  name = "ORRAA - High Quality Blue Carbon Principles",
  requirements = list(
    list(
      criterion = "Site-specific field measurements",
      threshold = "Required",
      check_function = function(data) {
        has_field_data <- !is.null(data$cores) && nrow(data$cores) > 0
        n_sites <- if (has_field_data) n_distinct(data$cores$core_id) else 0

        message <- if (has_field_data) {
          sprintf("Field data from %d cores", n_sites)
        } else {
          "FAIL: No field measurements"
        }

        list(pass = has_field_data, value = n_sites, message = message)
      }
    ),
    list(
      criterion = "Stratum-specific assessments",
      threshold = "Required",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = 0, message = "No carbon stock data"))

        n_strata <- sum(data$carbon_stocks$stratum != "ALL")
        has_strata <- n_strata > 0

        message <- if (has_strata) {
          sprintf("Stratum-specific estimates for %d strata", n_strata)
        } else {
          "FAIL: No stratum-specific estimates"
        }

        list(pass = has_strata, value = n_strata, message = message)
      }
    ),
    list(
      criterion = "Uncertainty quantification",
      threshold = "Required (95% confidence intervals)",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        has_uncertainty <- "conservative_stock_0_100_Mg_ha" %in% names(data$carbon_stocks)

        message <- if (has_uncertainty) {
          "Uncertainty quantified with 95% CI"
        } else {
          "FAIL: Uncertainty not quantified"
        }

        list(pass = has_uncertainty, value = has_uncertainty, message = message)
      }
    ),
    list(
      criterion = "Transparency and documentation",
      threshold = "Full methodology documentation",
      check_function = function(data) {
        # Check for diagnostic outputs
        has_diagnostics <- !is.null(data$cv_results) || !is.null(data$qc_summary)

        message <- if (has_diagnostics) {
          "Documentation and diagnostics available"
        } else {
          "WARNING: Limited diagnostic documentation"
        }

        list(pass = has_diagnostics, value = has_diagnostics, message = message)
      }
    )
  )
)

# IPCC Wetlands Supplement
ipcc_criteria <- list(
  name = "IPCC Wetlands Supplement",
  requirements = list(
    list(
      criterion = "Tier 3 approach (site-specific data)",
      threshold = "Recommended for accuracy",
      check_function = function(data) {
        has_field_data <- !is.null(data$cores) && nrow(data$cores) > 0
        n_cores <- if (has_field_data) n_distinct(data$cores$core_id) else 0

        tier <- if (n_cores >= 10) {
          "Tier 3"
        } else if (n_cores >= 3) {
          "Tier 2/3"
        } else {
          "Tier 1/2"
        }

        message <- sprintf("%s approach (%d field cores)", tier, n_cores)

        list(pass = n_cores >= 3, value = tier, message = message)
      }
    ),
    list(
      criterion = "Conservative approach for uncertainty",
      threshold = "Required for credible estimates",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        has_conservative <- "conservative_stock_0_100_Mg_ha" %in% names(data$carbon_stocks)

        message <- if (has_conservative) {
          "Conservative (lower bound) estimates used"
        } else {
          "FAIL: Conservative approach not applied"
        }

        list(pass = has_conservative, value = has_conservative, message = message)
      }
    )
  )
)

# Canadian Blue Carbon Network Standards
canadian_criteria <- list(
  name = "Canadian Blue Carbon Network Standards",
  requirements = list(
    list(
      criterion = "Regional context integration",
      threshold = "Canadian ecosystem parameters",
      check_function = function(data) {
        # Check if Canadian-specific parameters are used
        # This would require checking if Canadian literature DB is used for Bayesian priors
        using_canadian_params <- exists("CANADIAN_LITERATURE_DB") && file.exists(CANADIAN_LITERATURE_DB)

        message <- if (using_canadian_params) {
          "Canadian ecosystem parameters integrated"
        } else {
          "INFO: Canadian literature database available but not used in this analysis"
        }

        list(pass = TRUE, value = using_canadian_params, message = message)
      }
    ),
    list(
      criterion = "Spatial prediction validation",
      threshold = "Cross-validation required",
      check_function = function(data) {
        has_cv <- !is.null(data$cv_results) && nrow(data$cv_results) > 0

        if (has_cv) {
          mean_r2 <- mean(data$cv_results$cv_r2, na.rm = TRUE)
          pass <- mean_r2 >= 0.5  # Reasonable threshold

          message <- if (pass) {
            sprintf("Spatial validation acceptable (R¬≤ = %.3f)", mean_r2)
          } else {
            sprintf("WARNING: Low spatial prediction accuracy (R¬≤ = %.3f)", mean_r2)
          }
        } else {
          pass <- FALSE
          message <- "FAIL: No spatial validation performed"
        }

        list(pass = pass, value = if (has_cv) mean_r2 else NA, message = message)
      }
    ),
    list(
      criterion = "Provincial reporting compatibility",
      threshold = "BC/Provincial standards",
      check_function = function(data) {
        # Check if processing CRS is appropriate for province
        is_bc_crs <- PROCESSING_CRS %in% c(3005, 3347, 32610, 32611)

        message <- if (is_bc_crs) {
          sprintf("Compatible CRS for BC (EPSG:%d)", PROCESSING_CRS)
        } else {
          sprintf("INFO: Non-BC CRS used (EPSG:%d)", PROCESSING_CRS)
        }

        list(pass = TRUE, value = PROCESSING_CRS, message = message)
      }
    )
  )
)

# Store all standards
all_standards <- list(
  VM0033 = vm0033_criteria,
  ORRAA = orraa_criteria,
  IPCC = ipcc_criteria,
  Canadian = canadian_criteria
)

# ============================================================================
# LOAD ALL AVAILABLE DATA
# ============================================================================

log_message("\nLoading all available data from workflow...")

workflow_data <- list(
  cores = NULL,
  carbon_stocks = NULL,
  cv_results = NULL,
  qc_summary = NULL,
  spatial_predictions = list(),
  diagnostics = list()
)

# Load harmonized cores
if (file.exists("data_processed/cores_harmonized_bluecarbon.rds")) {
  workflow_data$cores <- readRDS("data_processed/cores_harmonized_bluecarbon.rds")
  log_message(sprintf("  Loaded %d cores from %d sites",
                     nrow(workflow_data$cores),
                     n_distinct(workflow_data$cores$core_id)))
} else {
  log_message("  Harmonized cores not found", "WARNING")
}

# Load carbon stocks (try both RF and Kriging)
for (method in c("rf", "kriging")) {
  vm0033_file <- sprintf("outputs/carbon_stocks/carbon_stocks_conservative_vm0033_%s.csv", method)
  if (file.exists(vm0033_file)) {
    stocks <- tryCatch({
      read.csv(vm0033_file)
    }, error = function(e) {
      log_message(sprintf("  Could not load %s carbon stocks: %s", method, e$message), "WARNING")
      NULL
    })

    if (!is.null(stocks) && nrow(stocks) > 0) {
      stocks$method <- method
      workflow_data$carbon_stocks <- rbind(workflow_data$carbon_stocks, stocks)
      log_message(sprintf("  Loaded %s carbon stocks", method))
    } else {
      log_message(sprintf("  %s carbon stocks file is empty", method), "WARNING")
    }
  }
}

# Load cross-validation results
for (method in c("rf", "kriging")) {
  cv_file <- sprintf("diagnostics/crossvalidation/%s_cv_results.csv", method)
  if (file.exists(cv_file)) {
    cv_data <- tryCatch({
      read.csv(cv_file)
    }, error = function(e) {
      log_message(sprintf("  Could not load %s CV results: %s", method, e$message), "WARNING")
      NULL
    })

    if (!is.null(cv_data) && nrow(cv_data) > 0) {
      cv_data$method <- method
      workflow_data$cv_results <- rbind(workflow_data$cv_results, cv_data)
      log_message(sprintf("  Loaded %s CV results", method))
    } else {
      log_message(sprintf("  %s CV results file is empty", method), "WARNING")
    }
  }
}

# Count available spatial predictions
for (method in c("rf", "kriging")) {
  pred_dir <- file.path("outputs/predictions", method)
  if (dir.exists(pred_dir)) {
    pred_files <- list.files(pred_dir, pattern = "\\.tif$", full.names = TRUE)
    workflow_data$spatial_predictions[[method]] <- pred_files
    log_message(sprintf("  Found %d %s prediction rasters", length(pred_files), method))
  }
}

# Check for Bayesian posterior outputs
if (USE_BAYESIAN && dir.exists("outputs/predictions/posterior")) {
  post_files <- list.files("outputs/predictions/posterior", pattern = "\\.tif$", full.names = TRUE)
  workflow_data$spatial_predictions[["posterior"]] <- post_files
  log_message(sprintf("  Found %d Bayesian posterior rasters", length(post_files)))
}

log_message("Data loading complete")

# ============================================================================
# RUN COMPLIANCE CHECKS FOR ALL STANDARDS
# ============================================================================

log_message("\n=== RUNNING STANDARDS COMPLIANCE CHECKS ===")

compliance_results <- list()

for (standard_name in names(all_standards)) {
  standard <- all_standards[[standard_name]]

  log_message(sprintf("\nChecking: %s", standard$name))

  standard_results <- list(
    standard_name = standard$name,
    checks = list(),
    pass_count = 0,
    fail_count = 0,
    warning_count = 0,
    na_count = 0
  )

  for (req in standard$requirements) {
    log_message(sprintf("  Checking: %s", req$criterion))

    result <- tryCatch({
      req$check_function(workflow_data)
    }, error = function(e) {
      list(pass = FALSE, value = NA, message = paste("ERROR:", e$message))
    })

    result$criterion <- req$criterion
    result$threshold <- req$threshold

    # Count outcomes
    if (is.na(result$pass)) {
      standard_results$na_count <- standard_results$na_count + 1
    } else if (result$pass) {
      standard_results$pass_count <- standard_results$pass_count + 1
    } else {
      standard_results$fail_count <- standard_results$fail_count + 1
    }

    standard_results$checks[[req$criterion]] <- result

    log_message(sprintf("    %s", result$message))
  }

  compliance_results[[standard_name]] <- standard_results
}

# ============================================================================
# GENERATE RECOMMENDATIONS
# ============================================================================

log_message("\n=== GENERATING RECOMMENDATIONS ===")

recommendations <- list()

# Recommendation 1: Sample size improvements
if (!is.null(workflow_data$cores)) {
  samples_per_stratum <- workflow_data$cores %>%
    group_by(stratum) %>%
    summarise(n_cores = n_distinct(core_id), .groups = "drop")

  understrata <- samples_per_stratum %>%
    filter(n_cores < VM0033_MIN_CORES)

  if (nrow(understrata) > 0) {
    for (i in 1:nrow(understrata)) {
      needed <- VM0033_MIN_CORES - understrata$n_cores[i]
      recommendations[[length(recommendations) + 1]] <- list(
        priority = "HIGH",
        category = "Sampling",
        recommendation = sprintf("Collect %d additional cores in '%s' stratum to meet VM0033 minimum (%d cores currently, %d required)",
                                needed, understrata$stratum[i], understrata$n_cores[i], VM0033_MIN_CORES),
        standard = "VM0033",
        action = sprintf("Add %d cores", needed)
      )
    }
  }
}

# Recommendation 2: Precision improvements
if (!is.null(workflow_data$carbon_stocks)) {
  high_uncertainty <- workflow_data$carbon_stocks %>%
    filter(stratum != "ALL") %>%
    mutate(
      relative_error = ifelse(mean_stock_0_100_Mg_ha > 0,
                             100 * (mean_stock_0_100_Mg_ha - conservative_stock_0_100_Mg_ha) / mean_stock_0_100_Mg_ha,
                             NA)
    ) %>%
    filter(relative_error > VM0033_TARGET_PRECISION)

  if (nrow(high_uncertainty) > 0) {
    for (i in 1:nrow(high_uncertainty)) {
      # Estimate additional samples needed using coefficient of variation
      current_samples <- if (!is.null(workflow_data$cores)) {
        workflow_data$cores %>%
          filter(stratum == high_uncertainty$stratum[i]) %>%
          summarise(n = n_distinct(core_id)) %>%
          pull(n)
      } else {
        3
      }

      # Using sample size formula: n = (z * CV / target_error)^2
      # Assuming CV ‚âà 30%, z = 1.96, target = 20%
      required_samples <- ceiling((1.96 * VM0033_ASSUMED_CV / VM0033_TARGET_PRECISION)^2)
      additional_needed <- max(0, required_samples - current_samples)

      if (additional_needed > 0) {
        recommendations[[length(recommendations) + 1]] <- list(
          priority = "MEDIUM",
          category = "Precision",
          recommendation = sprintf("Collect ~%d additional cores in '%s' to reduce uncertainty from %.1f%% to target %.0f%%",
                                  additional_needed, high_uncertainty$stratum[i],
                                  high_uncertainty$relative_error[i], VM0033_TARGET_PRECISION),
          standard = "VM0033",
          action = sprintf("Add ~%d cores", additional_needed)
        )
      }
    }
  }
}

# Recommendation 3: Spatial validation improvements
if (!is.null(workflow_data$cv_results)) {
  poor_cv <- workflow_data$cv_results %>%
    filter(cv_r2 < 0.5)

  if (nrow(poor_cv) > 0) {
    unique_methods <- unique(poor_cv$method)
    for (method in unique_methods) {
      recommendations[[length(recommendations) + 1]] <- list(
        priority = "MEDIUM",
        category = "Model Performance",
        recommendation = sprintf("Improve %s model performance (R¬≤ < 0.5). Consider: (1) Adding environmental covariates, (2) Checking for spatial autocorrelation, (3) Increasing sample size in poorly predicted areas",
                                toupper(method)),
        standard = "Canadian/ORRAA",
        action = "Improve model covariates or sampling"
      )
    }
  }
}

# Recommendation 4: Bayesian posterior integration
if (!USE_BAYESIAN && length(workflow_data$spatial_predictions) > 0) {
  recommendations[[length(recommendations) + 1]] <- list(
    priority = "LOW",
    category = "Analysis Enhancement",
    recommendation = "Consider enabling Bayesian workflow (Module 06c) to integrate SoilGrids priors and reduce uncertainty, especially in undersampled areas",
    standard = "All standards",
    action = "Set USE_BAYESIAN = TRUE in config"
  )
}

# Recommendation 5: Temporal monitoring
if (MONITORING_YEAR == format(Sys.Date(), "%Y")) {
  recommendations[[length(recommendations) + 1]] <- list(
    priority = "MEDIUM",
    category = "Monitoring",
    recommendation = sprintf("Establish baseline monitoring. Next verification required in %d years (Year %d) per VM0033",
                            VM0033_MONITORING_FREQUENCY,
                            as.numeric(MONITORING_YEAR) + VM0033_MONITORING_FREQUENCY),
    standard = "VM0033",
    action = sprintf("Schedule %d monitoring", as.numeric(MONITORING_YEAR) + VM0033_MONITORING_FREQUENCY)
  )
}

# If no recommendations, add positive note
if (length(recommendations) == 0) {
  recommendations[[1]] <- list(
    priority = "INFO",
    category = "Status",
    recommendation = "All standards compliance criteria met! Workflow is verification-ready.",
    standard = "All",
    action = "Proceed to verification"
  )
}

log_message(sprintf("Generated %d recommendations", length(recommendations)))

# ============================================================================
# CREATE COMPREHENSIVE REPORT
# ============================================================================

log_message("\nGenerating comprehensive HTML report...")

# Convert recommendations to data frame
recommendations_df <- do.call(rbind, lapply(recommendations, as.data.frame))

# Convert compliance results to data frame
compliance_summary <- do.call(rbind, lapply(names(compliance_results), function(std_name) {
  std <- compliance_results[[std_name]]
  data.frame(
    Standard = std$standard_name,
    Total_Checks = length(std$checks),
    Passed = std$pass_count,
    Failed = std$fail_count,
    Warnings = std$warning_count,
    NA_Checks = std$na_count,
    Compliance_Rate = round(100 * std$pass_count / (std$pass_count + std$fail_count), 1)
  )
}))

# Save CSVs
write_csv(compliance_summary, "outputs/reports/standards_compliance_summary.csv")
write_csv(recommendations_df, "outputs/reports/recommendations_action_plan.csv")

log_message("  Saved standards_compliance_summary.csv")
log_message("  Saved recommendations_action_plan.csv")

# ============================================================================
# BUILD HTML REPORT
# ============================================================================

html_content <- sprintf('
<!DOCTYPE html>
<html>
<head>
<title>%s - Comprehensive Standards Report</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 40px;
  background-color: #f5f5f5;
}
.header {
  background-color: #2c3e50;
  color: white;
  padding: 20px;
  margin: -40px -40px 40px -40px;
}
h1 { margin: 0; }
h2 {
  color: #2c3e50;
  border-bottom: 2px solid #3498db;
  padding-bottom: 10px;
  margin-top: 40px;
}
h3 {
  color: #34495e;
  margin-top: 30px;
}
.meta-info {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
table {
  width: 100%%;
  border-collapse: collapse;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 30px;
}
th {
  background-color: #3498db;
  color: white;
  padding: 12px;
  text-align: left;
}
td {
  padding: 10px;
  border-bottom: 1px solid #ddd;
}
tr:nth-child(even) {
  background-color: #f9f9f9;
}
.pass {
  background-color: #2ecc71;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: bold;
}
.fail {
  background-color: #e74c3c;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: bold;
}
.warning {
  background-color: #f39c12;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: bold;
}
.na {
  background-color: #95a5a6;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: bold;
}
.priority-high {
  color: #e74c3c;
  font-weight: bold;
}
.priority-medium {
  color: #f39c12;
  font-weight: bold;
}
.priority-low {
  color: #3498db;
}
.summary-box {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.stat {
  display: inline-block;
  margin-right: 30px;
  font-size: 18px;
}
.stat-value {
  font-size: 32px;
  font-weight: bold;
  color: #3498db;
}
</style>
</head>
<body>

<div class="header">
<h1>Comprehensive Blue Carbon Standards Compliance Report</h1>
<p style="margin: 10px 0 0 0; font-size: 16px;">%s</p>
</div>

<div class="meta-info">
<h3>Project Information</h3>
<p><strong>Project Name:</strong> %s</p>
<p><strong>Project Scenario:</strong> %s</p>
<p><strong>Monitoring Year:</strong> %d</p>
<p><strong>Report Generated:</strong> %s</p>
<p><strong>Location:</strong> %s</p>
</div>

<h2>Executive Summary</h2>

<div class="summary-box">
',
PROJECT_NAME,
PROJECT_DESCRIPTION,
PROJECT_NAME,
PROJECT_SCENARIO,
MONITORING_YEAR,
format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
PROJECT_LOCATION)

# Add summary statistics
if (!is.null(workflow_data$cores)) {
  n_cores <- n_distinct(workflow_data$cores$core_id)
  n_strata <- n_distinct(workflow_data$cores$stratum)
  html_content <- paste0(html_content, sprintf('
<div class="stat">
  <div class="stat-value">%d</div>
  <div>Field Cores</div>
</div>
<div class="stat">
  <div class="stat-value">%d</div>
  <div>Strata</div>
</div>
', n_cores, n_strata))
}

if (!is.null(workflow_data$carbon_stocks)) {
  total_stock <- workflow_data$carbon_stocks %>%
    filter(stratum == "ALL") %>%
    slice(1) %>%
    pull(total_stock_0_100_Mg)

  html_content <- paste0(html_content, sprintf('
<div class="stat">
  <div class="stat-value">%.0f</div>
  <div>Total Carbon (Mg C)</div>
</div>
', total_stock))
}

html_content <- paste0(html_content, sprintf('
<div class="stat">
  <div class="stat-value">%d</div>
  <div>Standards Checked</div>
</div>
</div>

<h2>Standards Compliance Summary</h2>

<table>
<tr>
  <th>Standard</th>
  <th>Total Checks</th>
  <th>Passed</th>
  <th>Failed</th>
  <th>Warnings</th>
  <th>Compliance Rate</th>
</tr>
', length(all_standards)))

# Add compliance summary rows
for (i in 1:nrow(compliance_summary)) {
  row <- compliance_summary[i, ]

  compliance_class <- if (row$Compliance_Rate >= 90) "pass" else if (row$Compliance_Rate >= 70) "warning" else "fail"

  html_content <- paste0(html_content, sprintf('
<tr>
  <td><strong>%s</strong></td>
  <td>%d</td>
  <td>%d</td>
  <td>%d</td>
  <td>%d</td>
  <td><span class="%s">%.1f%%</span></td>
</tr>
', row$Standard, row$Total_Checks, row$Passed, row$Failed, row$Warnings,
   compliance_class, row$Compliance_Rate))
}

html_content <- paste0(html_content, '
</table>
')

# Add detailed compliance checks for each standard
html_content <- paste0(html_content, '
<h2>Detailed Compliance Checks</h2>
')

for (standard_name in names(compliance_results)) {
  std <- compliance_results[[standard_name]]

  html_content <- paste0(html_content, sprintf('
<h3>%s</h3>
<table>
<tr>
  <th>Criterion</th>
  <th>Threshold</th>
  <th>Result</th>
  <th>Status</th>
</tr>
', std$standard_name))

  for (check_name in names(std$checks)) {
    check <- std$checks[[check_name]]

    status_class <- if (is.na(check$pass)) "na" else if (check$pass) "pass" else "fail"
    status_text <- if (is.na(check$pass)) "N/A" else if (check$pass) "PASS" else "FAIL"

    html_content <- paste0(html_content, sprintf('
<tr>
  <td><strong>%s</strong></td>
  <td>%s</td>
  <td>%s</td>
  <td><span class="%s">%s</span></td>
</tr>
', check$criterion, check$threshold, check$message, status_class, status_text))
  }

  html_content <- paste0(html_content, '
</table>
')
}

# Add recommendations
html_content <- paste0(html_content, sprintf('
<h2>Recommendations & Action Plan</h2>

<p><strong>%d recommendations identified for improving standards compliance and data quality:</strong></p>

<table>
<tr>
  <th>Priority</th>
  <th>Category</th>
  <th>Recommendation</th>
  <th>Standard</th>
  <th>Action Required</th>
</tr>
', nrow(recommendations_df)))

for (i in 1:nrow(recommendations_df)) {
  rec <- recommendations_df[i, ]

  priority_class <- paste0("priority-", tolower(rec$priority))

  html_content <- paste0(html_content, sprintf('
<tr>
  <td class="%s">%s</td>
  <td>%s</td>
  <td>%s</td>
  <td>%s</td>
  <td>%s</td>
</tr>
', priority_class, rec$priority, rec$category, rec$recommendation, rec$standard, rec$action))
}

html_content <- paste0(html_content, '
</table>
')

# Add data availability summary
html_content <- paste0(html_content, '
<h2>Data Availability</h2>

<div class="summary-box">
<h3>Workflow Outputs Found:</h3>
<ul>
')

if (!is.null(workflow_data$cores)) {
  html_content <- paste0(html_content, sprintf('
<li>‚úì Harmonized core data (%d cores)</li>
', n_distinct(workflow_data$cores$core_id)))
} else {
  html_content <- paste0(html_content, '
<li>‚úó Harmonized core data not found</li>
')
}

if (!is.null(workflow_data$carbon_stocks)) {
  methods <- unique(workflow_data$carbon_stocks$method)
  html_content <- paste0(html_content, sprintf('
<li>‚úì Carbon stock estimates (%s)</li>
', paste(methods, collapse = ", ")))
} else {
  html_content <- paste0(html_content, '
<li>‚úó Carbon stock estimates not found</li>
')
}

if (!is.null(workflow_data$cv_results)) {
  html_content <- paste0(html_content, sprintf('
<li>‚úì Cross-validation results (%d depth layers)</li>
', n_distinct(workflow_data$cv_results$depth_cm)))
} else {
  html_content <- paste0(html_content, '
<li>‚úó Cross-validation results not found</li>
')
}

for (method in names(workflow_data$spatial_predictions)) {
  n_rasters <- length(workflow_data$spatial_predictions[[method]])
  if (n_rasters > 0) {
    html_content <- paste0(html_content, sprintf('
<li>‚úì %s spatial predictions (%d rasters)</li>
', method, n_rasters))
  }
}

html_content <- paste0(html_content, '
</ul>
</div>

<h2>Next Steps</h2>

<div class="summary-box">
<ol>
<li><strong>Review all recommendations</strong> and prioritize high-priority actions</li>
<li><strong>Implement sampling improvements</strong> if any strata are below minimum requirements</li>
<li><strong>Validate spatial predictions</strong> in GIS software and check for anomalies</li>
<li><strong>Prepare verification documentation</strong> using outputs from Module 07 (VM0033 package)</li>
<li><strong>Submit to third-party verifier</strong> with all supporting data and QA/QC logs</li>
<li><strong>Establish monitoring schedule</strong> per VM0033 requirements (every 5 years)</li>
</ol>
</div>

<div style="margin-top: 50px; padding: 20px; background-color: #ecf0f1; border-radius: 8px;">
<p><strong>Report generated by:</strong> Blue Carbon Composite Sampling Workflow</p>
<p><strong>Module:</strong> 07b_comprehensive_standards_report.R</p>
<p><strong>Configuration:</strong> blue_carbon_config.R</p>
<p><strong>Session ID:</strong> ', SESSION_ID, '</p>
</div>

</body>
</html>
')

# Write HTML report
writeLines(html_content, "outputs/reports/comprehensive_standards_report.html")

log_message("  Saved comprehensive_standards_report.html")

# ============================================================================
# SUMMARY
# ============================================================================

cat("\n========================================\n")
cat("COMPREHENSIVE STANDARDS REPORT COMPLETE\n")
cat("========================================\n\n")

cat("Standards Assessed:\n")
cat("-------------------\n")
for (i in 1:nrow(compliance_summary)) {
  row <- compliance_summary[i, ]
  symbol <- if (row$Compliance_Rate >= 90) "‚úì" else if (row$Compliance_Rate >= 70) "‚ö†" else "‚úó"
  cat(sprintf("  %s %s: %.1f%% (%d/%d checks passed)\n",
              symbol, row$Standard, row$Compliance_Rate, row$Passed, row$Total_Checks))
}

cat("\nRecommendations:\n")
cat("----------------\n")
high_priority <- sum(recommendations_df$priority == "HIGH")
medium_priority <- sum(recommendations_df$priority == "MEDIUM")
low_priority <- sum(recommendations_df$priority == "LOW")

cat(sprintf("  HIGH priority: %d\n", high_priority))
cat(sprintf("  MEDIUM priority: %d\n", medium_priority))
cat(sprintf("  LOW priority: %d\n", low_priority))

cat("\nOutput Files:\n")
cat("-------------\n")
cat("  üìÑ Comprehensive Report: outputs/reports/comprehensive_standards_report.html\n")
cat("  üìä Compliance Summary: outputs/reports/standards_compliance_summary.csv\n")
cat("  üìã Action Plan: outputs/reports/recommendations_action_plan.csv\n")

cat("\nKey Actions:\n")
cat("------------\n")
if (high_priority > 0) {
  cat(sprintf("  ‚ö†Ô∏è  Address %d HIGH priority recommendations immediately\n", high_priority))
  # Show top high priority recommendations
  high_rec <- recommendations_df %>% filter(priority == "HIGH")
  for (i in 1:min(3, nrow(high_rec))) {
    cat(sprintf("     %d. %s\n", i, high_rec$recommendation[i]))
  }
} else {
  cat("  ‚úì No critical issues identified\n")
}

cat("\n")
log_message("=== MODULE 07B COMPLETE ===")
